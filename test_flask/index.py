# coding:utf-8
'''
首先，我们导入了 Flask 类。这个类的实例将会是我们的 WSGI 应用程序。
'''
from flask import Flask


'''
接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。
'''
app = Flask(__name__)


'''
然后，我们使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。
'''
@app.route('/')
def index():
    '''
    这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。
    :return:
    '''
    return 'This is index!!!'

@app.route('/user/<name>')
def user(name):
    return '<h1>Hello %s</h1>' % (name,)


'''
请求钩子：
有时候在请求之前或之后执行代码会很有用。
例如，在请求开始时，我们肯能需要创建数据库连接或者认证发起请求的用户。
为避免在每个视图函数中都使用重复的代码，Flask提供了注册通用函数功能，注册的函数可在请求被分发到视图函数之前或之后调用

请求钩子使用修饰器实现。Flask支持以下4种钩子：

1、before_first_request：注册一个函数，在处理第一个请求之前运行。
2、before_request：注册一个函数，在每次请求之前运行。
3、after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。
4、teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。

注意：在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。
例如：before_request处理程序可以从数据库中加载已登录用户，并将其保存在g.user中。随后调用视图函数时，视图函数再使用
g.user获取用户
'''



'''
响应：
Flask调用视图函数后，会将其返回值作为响应内容，大多数情况下，响应就是一个简单的字符串，作为HTML页面回送客户端

但HTTP协议需要的不仅仅是请求响应的字符串。HTTP响应中一个很重要的部分是状态码，Flask默认设为200，这个代码
表明请求已经被成功处理。

如果视图函数返回的响应需要使用不同的状态吗，那么可以把数字代码作为第二个返回值，添加到响应文本之后。

注意：视图函数返回的响应还可以接受第三个参数，这是一个由首部(header)组成的字典，可以添加到HTTP响应文本之后
一般情况下不需要这么做
如果不想返回由1个、2个或3个值组成的元组，Flask视图函数还可以返回Response对象。make_response()函数可以接受
1个、2个或3个参数（和视图函数的返回值一样），并返回一个Response对象。有时我们需要在视图函数中进行这种转换，然后
在响应对象上调用各种方法，近一步设置响应

有一种名为"重定向"的特殊响应类型，这种响应没有页面文档，只会告诉浏览器一个新地址用以加载新页面。重定向经常在
web表单中使用，重定向经常使用302状态码表示，指向的地址由Location首部提供。
重定向可以使用3个值形式的返回值生成，也可在Response对象中设定。不过，由于使用频繁，Flask提供了redirect()
辅助函数，用于生成这种响应

还有一种特殊的响应由abort函数生成，用于处理错误。

例如：下述视图函数返回一个400状态码，表示请求无效
例如：创建一个响应对象，然后设置cookie
例如：重定向
例如：abort处理错误
例如：自定义错误页面
'''
@app.route('/not-found')
def not_found():
    return '<h1>Not Found</h1>',400

from flask import make_response
@app.route('/set-response')
def set_response():
    response = make_response('<h1>This document carries a cookie!</h1>')
    response.set_cookie('username', 'the username')
    return response

from flask import redirect
@app.route('/set-redirect')
def set_redirect():
    return redirect('/')

from flask import abort
@app.route('/make-error/<id>')
def make_error(id):
    if id != '1':
        abort(404)#注意abort不会把控制权交还给调用他的函数，而是抛出异常把控制权交给Web服务器
    return 'hello %s' % id

#@app.route(404)
#def page_not_foiund():
#    return render_template('404.html'),404




#--------------------------------------------------------------------------------------------------
#
#
#---------------------------------3、模版-------------------------------------------------------
#
#模版是一个包含响应文本的文件，其中包含用占位变量表示动态部分，其具体值只在请求的上下文才能知道。
#使用真实的值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。为了渲染模版，Flask使用了一个名为Jinja2
#的强大模版引擎。
#--------------------------------------------------------------------------------------------------

'''
3.1、渲染模版

默认情况下，Flask在程序文件夹中的templates子文件夹中寻找模版
Flask提供的render_template函数把Jinja2模版引擎集成到了程序中，render_template函数的第一个参数是模版的文件名
随后的参数都是健值对，表示模版中变量对应的真实值。
'''
from flask import render_template
@app.route('/render-template/<name>')
def set_render_template(name):
    return render_template('hello.html',name=name)


'''
3.2、变量
在3.1的示例的hello.html中使用的{{ name }}结构表示一个变量，他是一种特殊的占位符，告诉模版引擎这个位置的值
从渲染模版时使用的数据中获取。Jinja2能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典、对象
在模版中使用变量的一些示例如下：

{{ mydict['key'] }}
{{ mylist[3] }}
{{ mylist[myintvar] }}
{{ myobj.somemethod() }}

注意：可以使用过滤器修改变量，过滤器名添加在变量名之后，之间使用竖线分隔：{{ name|capitalize }}
'''
#------------------------------------------------
#     过滤器名       |      说明
#------------------------------------------------
#       safe       |渲染值时不转义
#------------------------------------------------
#      capitalize   | 把值的首字母转换成大写，其他字母转换为小写
#------------------------------------------------
#      lower        |把值转换成小写
#------------------------------------------------
#       upper       |把值转换成大写
#------------------------------------------------
#       title       |把值中的每个单词的首字母都转换成大写
#------------------------------------------------
#       trim        |把值的首尾空格去掉
#------------------------------------------------
#       striptags   |渲染之前把值中所有的HTML标签都删掉
#------------------------------------------------

'''
3.2、控制结构
Jinja2提供了很多控制结构，可用来改变模版的渲染流程
条件控制语句：{% if xxx %}  {% else %} {% endif %}
for循环：{% for comment in comments %} {{ comment }} {% endfor %}
宏
模版继承：{% block 名称 %}{% endblock %}  {% extends "base.html" %}
'''


'''
3.3、链接
任何具有多个路由的程序都需要可以连接不同页面的链接，例如导航条。

在模板中直接编写简单的路由的URL链接不难，但对于包含可变部分的动态路由，在模版中构建正确的URL就很困难。
而且直接编写URL会对代码中定义的路由产生不必要的依赖关系。如果重新定义路由，模版中的链接可能会失效。

为了避免这些问题，Flask提供了url_for()辅助函数，它可以使用程序URL映射中保存的信息生成URL

url_for()函数最简单的用法是以视图函数名（或者app.add_url_route()定义路由时使用的端点名）作为参数
返回对应的URL，使用url_for()生成动态地址时，将动态部分作为关键字参数传入
传入url_for()的关键字参数不仅限于动态路由中的参数。函数能将
例如：url_for('user',name='john',_external=True)
'''



'''
3.4、静态文件
web程序不是仅由python代码和模版组成。大多数程序还会使用静态文件，例如HTML代码中引用的图片、js、css

在url映射时，其中有一个static路由。这是因为对静态文件的引用被当成一个特殊的路由，即/static/<filename>
例如，调用url_for('static',filename='css/style.css',_external=True)得到的结果是：
localhost:5000/static/css/style.css

默认设置下，Flask在程序根目录中名为static的子目录中寻找静态文件。如果需要，可在static文件夹中使用子文件夹
存放文件。服务器收到前面那个URL后，会生成一个响应，包含文件系统总static/css/style.css文件的内容
'''





if __name__=='__main__':
    '''
    程序收到客户端发来的请求时，要找到处理该请求的视图函数。
    为完成这个任务，Flask会在程序的URL映射中查找请求的URL。
    URL映射是URL和视图函数之间的对应关系。
    Flask使用app.route修饰器或者非修饰器形成的app.add_url_rule()生成映射
    URL映射中的HEAD、OPTION、GET是请求方法，由路由进行处理。
    Flask为每个路由都指定了请求方法，这样不同的请求方法发送到相同的URL上时，会使用不同的视图函数进行处理。
    '''
    print app.url_map    #这个是查看路由映射的


    '''
    最后我们用 run() 函数来让应用运行在本地服务器上。
    '''
    app.run(debug=True)





    '''外部可访问的服务器'''
    # 如果你运行了这个服务器，你会发现它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。
    # 如果你禁用了 debug 或信任你所在网络的用户，你可以简单修改调用 run() 的方法使你的服务器公开可用，如下:
    # app.run(host='0.0.0.0')这会让操作系统监听所有公网 IP。


    '''调试模式'''
    # 虽然 run() 方法适用于启动本地的开发服务器，但是你每次修改代码后都要手动重启它。
    # 这样并不够优雅，而且 Flask 可以做到更好。
    # 如果你启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。
    # 有两种途径来启用调试模式。一种是直接在应用对象上设置:app.debug = True app.run()
    # 另一种是作为 run 方法的一个参数传入:app.run(debug=True)